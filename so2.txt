jądro Linuxa (inaczej niż inne systemu) reprezentuja procesy jako zadania - task_struct. Proces jednoatkowy jest reprezentowany jako jedno zadanie a wielo jako wiele.

Dla każdego procesu składowany jest w pamięci deskryptor procesu służący do zarządania procesami przez jądro (struktura zadania opisuje stan procesu a deksryptor juz nie bardzo). Deskryptor jest tworzony w ramach instrukcji tworzącej sam proces.

Jądro składuje deksryptory wszsytkich procesów na liscie dwukierunkowej. PID można odwzorować na address struktury zadania tego procesu.

deskryptor procesu (task_struct) zawiera:
- info wykorzystywane przez planiste (czas na procesorze, wywłaszeń itd)
- obraz pamięci - wskaźniki do segmentu tekstu, danych i stosu lub tablice stron (info gdzie znalexc skladniki skladowe na dysku)
- info o sygnałach czyli maski itd.
- rejestry maszynowe - w razie wykonywania przez jądro płapki tutaj zapisywany jest konstekst procesora
- Stan wywołania systemowego ?
- Tablica deskryptorów plików
- Rozliczenia - też info o czasach
- Stos jądra 
- Różne

zad 2

przekierowanie - przekierowuje stdout procesu na początek pliku

Potok - jest rodzajem pseudopliku, który można wykorzystać do połączenia dwóch procesów. Jeśli procesy A i B chcą się ze sobą komunikować przez potok, muszą go wcześniej ustanowić. Kiedy proces A chce przesłać
dane do procesu B, zapisuje informacje w potoku tak, jakby był on plikiem wynikowym. W rzeczywistości implementacja potoku bardzo przypomina implementację pliku. Proces B może
czytać dane poprzez czytanie potoku w taki sposób, jakby był to plik wejściowy. Tak więc komunikacja między procesami w Uniksie wygląda bardzo podobnie do standardowych operacji odczytu
i zapisu plików.

LINUX
(
- struktura zdania wraz z deskryptorem nowego i razem z nim stos jądra, strutura thread_info i jakies inne rzeczy. Struktury w większości wypełniane są na podstawie procesu macierzystego
- Proces potomny otrzymuje identyfikator PID, własną mapę pamięci oraz współdzielony dostęp do plików swojego rodzica. Zaraz potem ustawia się rejestry nowego procesu
- generalnie segmnet tekstu nie zostaje przepisany, zamaist tego jest wspoldzielony bo jest read-only ale tak na serio wszsytko jest wspoldzielone dopóty dopóki nowy proces nie bedzie chciał czego zmodyfikować. W takim wypadku tworzona jest kopia strony pmaięci dawana jest już z naeżytymi prawami dostępu nowu procesowi
) (nowy proces ma swoja talbice ston ale strony nie sa skladodwany, skladuje je na bierzaco powodujac bledy stron)

fork i execv:
-wywołanie przechodzi w tryb jądra

-przydzelenie pamięci dla struktury zadania procesu potomnego
-wypełnienie struktury zadania potomnego danymi procesu rodzica
-przydzielenie pamięci dla stosu i przestrzeni użytkownika procesu potonego
-przydzielenie PID 
-Określenie że tekst ma by wspóldzielony
-kopiuje tablice stron dla danych i stosu
-określenie że otwarte pliki mają być współdzielone

- następuję powrót do procesu ( w końcu też do dziecka)
- wywolanie execv(nazwa polecenia, argumenty do niego, zmienne srodowiskowy/0)

-wywołanie przechodzi w tryb jądra

-odnajduje program wykonywalny
-sprawdza uprawdenia
-odczytuje i weryfukuje naglowek
-kopiuje argumenty i lansuchy srodowiskowe do jadra
-zwalnia stara prezstrzen adresowa (OBRAZ PAMIEC!!!!)
-przydziela nowa (ORAZ PAMIECI!!!!)
-kopiuje zmienne i lancuchy srodowiskowe na stos
-zeruje sygnaly
-inicjalizuje rejestry

WinNT

- w trybie uzytkownika wywolywane jest CreateProcess  znazwa pliku
- CreateProcess  gromadzi parametry do stworzenia procesu i przekazuje je NtCreateUserProcess, kotre wykonywane jest w trybie jadra
- zostaje stworzony zupełnie nowy proces a nie kopia jak w linuxie.
(Stworzony proces nie otrzymuje kopii pamięci swojego rodzica CreateProcess można w pewien sposób porównać do połączenia fork z execve.)

Procesor CPU np. może być wyposażony w oddzielne jednostki do pobierania, dekodowania i uruchamiania instrukcji. Dzięki temu, kiedy procesor uruchamia instrukcję n, może w tym samym czasie dekodować instrukcję n+1 i pobierać instrukcję n+2. Taka organizacja nosi nazwę potoku.



wywołanie naraz połączonego wywołania fork()+execve() jako spawn() pozbawia nas mozliwości wprowadzania zmian pomiędzy wywołaniami fork i execve

OSTATNEI PYTANIE!!!!!!!
chodzi o otwarte deskryptory, które domyślnie są diedziczone i metoda spawn() nie daje czasu na iterwencje a normalnie po fork moglibysmhy pozamykac deskryptory i dopiero a pipey tez cos w tym stylu





















zad 1


stan procesu - stan dzialania procesów, monitorowanie i zarządzanie działaniem procesów w systemie.

zablokowanie sygnalu - zapalenie bitu w masce blokujacej sygnaly (chyba w deskryptorze prescesu)

zignorowanie sygnalu - za pomoca funckji sigaction nalezy ustawic obsluzenie sygnalu funkcja, ktora nic nie robi

sen przerywalny - może być przerwany, co oznacza, że może reagować na sygnały i kontynuować swoje działanie. Stan ten jest oznaczany literą "S" - rocesy w stanie przerywalnym często oczekują na zdarzenia wejścia/wyjścia, takie jak odczytanie danych z dysku twardego, pobranie danych z sieci lub oczekiwanie na dane z urządzenia wejścia/wyjścia. Procesy w stanie przerywalnym są aktywne i mogą być wznowione po zakończeniu operacji wejścia/wyjścia lub po otrzymaniu odpowiedniego sygnału.

sen nieprzerywalny - Procesy w stanie nieprzerywalnym zazwyczaj reprezentują operacje wejścia/wyjścia, które wymagają dostępu do urządzeń blokujących lub operacje związane z systemem plików, na przykład synchronizację metadanych na dysku. Jeśli taki proces napotka problem lub błąd, który utknął go w stanie nieprzerywalnym, może to prowadzić do konieczności restartowania systemu lub ręcznego zrestartowania procesu, co jest zazwyczaj ostatecznością. Proces w stanie nieprzerywalnym jest w stanie usypienia, ale nie może być przerwany przez standardowe sygnały, takie jak SIGINT (Ctrl+C) czy SIGTERM. Stan ten jest oznaczany literą "D" w wynikach polecenia ps



The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored - no wiec SIGSEGV mozna dotykac
(po zignorowaniu SIGSEGV zapetlamy sie bo nie idziemy do nastenej istrukcji tylko do tej samej)
 
---
Stopped - proces został zatrzymany i można go wznowić tylko poprzez pozytywne działanie innego procesu. Na przykład debugowany proces można ustawić w stan zatrzymania do momentu otrzymania sygnału SIGCONT.

RUNNING STATE
Ready - proces załadowany do pamięci, czeka na przydzielenie czasu CPU przez scheduler
Executing -  proces wykonywany przez CPU

Zombie -  proces zakończony, ale nie pogrzebany

Uninteraptible - est to stan zablokowany. W stanie nieprzerywalnym proces oczekuje bezpośrednio na warunki sprzętowe i dlatego nie będzie obsługiwał żadnych sygnałów poza dwoma - najczęściej dostępu do dysku np. mkdir 
Interaptixble - jest to stan zablokowany, w którym proces oczekuje na zdarzenie, takie jak zakończenie operacji we / wy, dostępność zasobu lub sygnał z innego procesu.
---

przejścia wyzwalające zmiany stanów:

jądro systemu operacyjnego:
Executing -> Ready : Gdy process trwa zbyt długo to jądro systemu może zmienić jego stan

kod sterowników:
Interruptible -> Running: Powiadomienie o dostępnym pakiecie przez kartę sieciową może zmienić stan procesu

proces użytkownika:
Running -> Stopped: Wysłanie sygnału zatrzymującego (np Ctrl+Z w terminalu lub kill -SIGTSTP <pid> wysłany przez proces) przez proces do innego procesu, przez co zmieni się jego stan







zad 3

FORK	

Najwazniejsze zasoby procesu dziedziczone przez proces potomny:
- wpisy w  process table entry są dziedziczone tzn, że wstazują na te same struktury (np. file table)
- kopia data space, jheap, stack ale za to wspodzielą segment text ( ale tak serio to nie sa one od razu kopiowane tylko wykrozystana jest technika copy-on-write )

moreover
Real user ID, real group ID, effective user ID, and effective group ID
 Supplementary group IDs
 Process group ID
 Session ID
 Controlling terminal
 The set-user-ID and set-group-ID flags
 Current working directory
 Root directory
 File mode creation mask
 Signal mask and dispositions
 The close-on-exec flag for any open file descriptors
 Environment
 Attached shared memory segments
 Memory mappings
 Resource limits

The differences between the parent and child are
 The return values from fork are different.
 The process IDs are different.
 The two processes have different parent process IDs: the parent process ID of the child is the parent; the parent process ID of the parent doesn’t change.
 The child’s tms_utime, tms_stime, tms_cutime, and tms_cstime values are set to 0 (these times are discussed in Section 8.17).
 File locks set by the parent are not inherited by the child.
 Pending alarms are cleared for the child.
 The set of pending signals for the child is set to the empty set.




EXECVE

int execve(const char *pathname, char *const argv[], char *const envp[]);

twirane są bebchy (deksryptor procesu albo struktura zadania(?)) i wymieniane są text, data, heap, stack segments with brand new program from disk
przez argument exxecve dostarczane sa zmienne srodowiskowe

loaded program inherits additional properties from the calling process:
 Process ID and parent process ID
 Real user ID and real group ID
 Supplementary group IDs
 Process group ID
 Session ID
 Controlling terminal
 Time left until alarm clock
 Current working directory
 Root directory
 File mode creation mask
 File locks
 Process signal mask
 Pending signals
 Resource limits
 Nice value (on XSI-conformant systems; see Section 8.16)
 Values for tms_utime, tms_stime, tms_cutime, and tms_cstime





 orożnianie buforów stdio(3):

 sa one posrednikami miedzy procesem wyjsciem.
 Jezeli zostana one wypelnione danymi przed fork() to oba procesy beda mialy kopie tych samych danych. Moze to prowadzic do podwojnego wypisania tych samych danych
 LUB bufory stdio moga zawierac zmienne stanu tj. pozycja awskaznika pliku. (torche smierdzi - w kocnu sa table entry)
(
When you fork the process in, the child processes inherits every part of the parent process, including the unflushed output buffer. This effectively copies the unflushed buffer to each child process. So each child process would read the same buffer. It is good practice to call fflush() on all streams with pending output before calling fork() or to let the forked child call explicitly _exit() that only exits the process without flushing the stdio streams.
)

Co jądro robi w trakcie wywołania execve z konfiguracją zainstalowanych procedur obsługi sygnałów

Moze zdarzyc sie sytuacja, w której proces zmieni standardowa obsługę pewnych sygnałów, a nastepnie wywola inny program poleceniem exec. Nie zawsze pozostawienie niezmienionej obsługi sygnałów przy zmianie kontekstu da oczekiwany wynik (przy czyszczeniu shared memory czy stack/heap kod obsługi sygnałów mogl przestac istniec). Z drugiej strony, przywrócenie standardowej obsługi wszystkich sygnałów pozbawiłoby twórców oprogramowania silnego narzędzia programistycznego. Wybrane w Unixie rozwiązanie kompromisowe przywraca standardowa obsługę tylko tych sygnałów, dla których ustawiono wcześniej nowa procedure obslugi. Oznacza to, ze sygnały, które były ignorowane w programie wywołującym, pozostaną takimi w programie wywoływanym. Za zmianę sposobu reagowania na sygnały odpowiada procedura flush_old_signals.







zad 4

kill function deafult signal is SIGTERM	

SigQ   This  field contains two slash-separated numbers that relate to queued signals for
                     the real user ID of this process.  The first of these is the number  of  currently
                     queued  signals for this real user ID, and the second is the resource limit on the
                     number of queued signals for this process (see the description of  RLIMIT_SIGPEND‐
                     ING in getrlimit(2)).

SigPnd, ShdPnd
                     Mask (expressed in hexadecimal) of signals pending for thread and for process as a
                     whole (see pthreads(7) and signal(7)).o
	

SigBlk, SigIgn, SigCgt
                     Masks (expressed in hexadecimal) indicating signals being  blocked,  ignored,  and
                     caught (see signal(7)).


SigQ:	0/60892
SigPnd:	0000000000000000
ShdPnd:	0000000000000000
SigBlk:	0000000000010000
SigIgn:	0000000000384004
SigCgt:	000000004b813efb

generalnie uruchamiam xeyes, sprawdzam jego pida ps -ef | grep "xeyes" i generalnie wysylam sygnal kill -18 <jego pid> (to jest SIGTSTP)
otwiram goscia cat /proc/<pid>/status wysylam inne sygnaly i sprawdzam jak sie kolejkuja


kolejnosc dostarczenia sygnalow pokazana jest w indexach - kill -L














zad 5



#include <sys/types.h>
#include <sys/wait.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define LEN(x)	(sizeof (x) / sizeof *(x))
#define TIMEO	30

static void sigpoweroff(void);
static void sigreap(void);
static void sigreboot(void);
static void spawn(char *const []);

static struct {
	int sig;
	void (*handler)(void);
} sigmap[] = {
	{ SIGUSR1, sigpoweroff },
	{ SIGCHLD, sigreap     },
	{ SIGALRM, sigreap     },
	{ SIGINT,  sigreboot   },
};

#include "config.h"

static sigset_t set;

int
main(void)
{
	int sig;
	size_t i;

	if (getpid() != 1)
		return 1;
	chdir("/");
	sigfillset(&set);
	sigprocmask(SIG_BLOCK, &set, NULL);
	spawn(rcinitcmd);
	while (1) {
		alarm(TIMEO);
		sigwait(&set, &sig);
		for (i = 0; i < LEN(sigmap); i++) {
			if (sigmap[i].sig == sig) {
				sigmap[i].handler();
				break;
			}
		}
	}
	/* not reachable */
	return 0;
}

static void
sigpoweroff(void)
{
	spawn(rcpoweroffcmd);
}

static void
sigreap(void)
{
	while (waitpid(-1, NULL, WNOHANG) > 0)
		;
	alarm(TIMEO);
}

static void
sigreboot(void)
{
	spawn(rcrebootcmd);
}

static void
spawn(char *const argv[])
{
	switch (fork()) {
	case 0:
		sigprocmask(SIG_UNBLOCK, &set, NULL);
		setsid();
		execvp(argv[0], argv);
		perror("execvp");
		_exit(1);
	case -1:
		perror("fork");
	}
}


Minimalny program rozruchowy dostaje sie do katalogu glownego "chdir("/")", podnosi wszsytkie bity we wczesniej zinicjalizowanej masce sygnałłów (dzieki temu zedan sygnal poza dwoma nie zmieni pracy processu)
Nastepnie poleceniem sigprocmask i argumentami SIG_BLOCK, &set, NULL ustawia wczesniej zbudowaną maskę jako już faktyczą prawdziwą z krwi i kości.
Wywołuje funckję init, po czym czuwa czy są wysyłane sygnały zawarte w masce set. Gdy taki sygnał zostanie odbrany jego nr zapisze zmienna sig. Jezeli przez 30s process nie otrzyma zadnego sygnalu z set to otrzyma sygnal wygenerowany przez alarm(), co spowoduje obsluzenie sigreap widac wszystko nie ma co pisac


sigwait(&set, &sig) jest używana w języku C w systemach Unixowych do synchronicznej oczekiwanie na sygnał z określonej maski sygnałów set. Oznacza to, że program zostanie zatrzymany (zawieszony) do momentu odebrania jednego z sygnałów wskazanych w masce set. Gdy taki sygnał zostanie odebrany, jego numer sygnału zostanie zapisany do zmiennej sig, a program będzie kontynuowany.

sigprocmask(SIG_BLOCK, &set, NULL); jest używane w języku C w systemach Unixowych, aby nadac realne znaczenie sygnałom określone w masce sygnałów set (znacznenie u nas SIG_BLOCK)

A jak grzebie dzieci no tez widac czeka sobie na sygnal, gdy mija czas obluhuje SIGALRM i robi waitpid-a, gdy juz pogrzebie albo niczego do pogrzebania nie bedzie to wlacza timer i wraca do while-a w ciele main-a


jak reaguje na sygnaly z maski?
SIGINT - uruchamia system od nowa
SIGCHLD i SIGALRM - jezeli moze to grzebie, ustawia timer i wraca do instrukcji + 1 sprzed sygnału
SIGUSR1 - wylacza sysytem


